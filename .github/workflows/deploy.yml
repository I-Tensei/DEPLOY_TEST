name: Deploy to AWS EC2

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Java 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'corretto'

      - name: Setup Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'frontend/package-lock.json'

      - name: Cache Maven
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-m2-

      - name: Build backend
        run: |
          cd backend/demo
          mvn -T 2C -B clean package -DskipTests

      - name: Build frontend
        working-directory: frontend
        run: |
          npm ci --no-audit --no-fund
          npm run build

      - name: Pre-check Bastion:22
        run: |
          BASTION="${{ secrets.BASTION_HOST }}"
          timeout 5 bash -c "</dev/tcp/${BASTION}/22" || { echo "Bastion:22 unreachable"; exit 1; }

      - name: SSH handshake warm-up
        shell: bash
        env:
          BASTION: ${{ secrets.BASTION_HOST }}
        run: |
          KEY=$(mktemp)
          printf "%s" "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > "$KEY" && chmod 600 "$KEY"
          # Quick handshake retries; non-fatal (banner exchange can be flaky)
          for i in 1 2 3 4 5; do
            if ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=8 -o ConnectionAttempts=1 -o IPQoS=none -i "$KEY" ec2-user@"$BASTION" 'echo ok' ; then
              echo "Handshake OK"; break; fi
            echo "Handshake try $i failed; retrying..."; sleep 3
          done || true
          rm -f "$KEY"
          # Do not fail here; upload step has its own retries

      - name: Upload artifacts to Bastion
        shell: bash
        env:
          BASTION: ${{ secrets.BASTION_HOST }}
        run: |
          set -e
          KEY=$(mktemp)
          printf "%s" "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > "$KEY" && chmod 600 "$KEY"
          # Pack frontend as a single tarball to avoid scp -r overhead
          [ -d frontend/build ] || { echo "No frontend build dir"; exit 1; }
          tar -C frontend/build -czf frontend_build.tgz .
          upload() {
            src="$1"; dst="$2";
            timeout 240 scp -C \
              -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              -o PreferredAuthentications=publickey -o IdentitiesOnly=yes \
              -o ConnectTimeout=25 -o ServerAliveInterval=15 -o ServerAliveCountMax=3 -o IPQoS=none \
              -i "$KEY" "$src" ec2-user@"$BASTION":"$dst";
          }
          for f in 1 2 3 4 5; do
            if upload frontend_build.tgz /tmp/frontend_build.tgz; then ok1=1; break; fi
            d=$(( 2**(f-1) )); if [ $d -gt 10 ]; then d=10; fi
            echo "Retry scp frontend ($f/5) after ${d}s..."; sleep "$d";
          done
          [ "${ok1:-0}" = "1" ] || { echo "Upload frontend failed"; exit 1; }
          for f in 1 2 3 4 5; do
            if upload backend/demo/target/demo-0.0.1-SNAPSHOT.jar /tmp/demo-0.0.1-SNAPSHOT.jar; then ok2=1; break; fi
            d=$(( 2**(f-1) )); if [ $d -gt 10 ]; then d=10; fi
            echo "Retry scp jar ($f/5) after ${d}s..."; sleep "$d";
          done
          [ "${ok2:-0}" = "1" ] || { echo "Upload jar failed"; exit 1; }
          rm -f frontend_build.tgz
          rm -f "$KEY"

      - name: Deploy on Bastion (nginx + backend)
        continue-on-error: true
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.BASTION_HOST }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          timeout: 300s
          command_timeout: 600s
          script: |
            set -e
            command -v nginx >/dev/null 2>&1 || sudo dnf -y install nginx || sudo yum -y install nginx || true
            sudo systemctl enable --now nginx || true
            if command -v getenforce >/dev/null 2>&1 && [ "$(getenforce)" = "Enforcing" ]; then sudo setsebool -P httpd_can_network_connect 1 || true; fi
            if [ -f "/tmp/frontend_build.tgz" ]; then
              sudo rm -rf /usr/share/nginx/html/*
              sudo mkdir -p /usr/share/nginx/html
              sudo tar -xzf /tmp/frontend_build.tgz -C /usr/share/nginx/html
              rm -f /tmp/frontend_build.tgz
            fi
            sudo rm -f /etc/nginx/conf.d/*.conf || true
            sudo bash -lc '{
              echo "server {";
              echo "  listen 0.0.0.0:80;";
              echo "  listen [::]:80;";
              echo "  location / {";
              echo "    root /usr/share/nginx/html;";
              echo "    index index.html index.htm;";
              echo "    try_files \$uri \$uri/ /index.html;";
              echo "  }";
              echo "  location /api {";
              echo "    proxy_pass http://127.0.0.1:8080;";
              echo "    proxy_set_header Host \$host;";
              echo "    proxy_set_header X-Real-IP \$remote_addr;";
              echo "    proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;";
              echo "    proxy_set_header X-Forwarded-Proto \$scheme;";
              echo "  }";
              echo "}";
            } | sudo tee /etc/nginx/conf.d/app.conf >/dev/null'
            sudo nginx -t && sudo systemctl restart nginx
            command -v java >/dev/null 2>&1 || sudo dnf -y install java-17-openjdk-headless || sudo yum -y install java-17-openjdk-headless || true
            [ -f /tmp/demo-0.0.1-SNAPSHOT.jar ] && mv -f /tmp/demo-0.0.1-SNAPSHOT.jar /home/ec2-user/demo-0.0.1-SNAPSHOT.jar
            pkill -f 'demo-0.0.1-SNAPSHOT.jar' || true
            mkdir -p /home/ec2-user/data
            nohup java -jar /home/ec2-user/demo-0.0.1-SNAPSHOT.jar --server.address=0.0.0.0 \
              --spring.datasource.url=jdbc:h2:file:/home/ec2-user/data/demo_db\;AUTO_SERVER=TRUE\;DB_CLOSE_DELAY=-1\;MODE=MySQL \
              --spring.datasource.driverClassName=org.h2.Driver \
              --spring.datasource.username=sa --spring.datasource.password= \
              --spring.jpa.hibernate.ddl-auto=update \
              --spring.jpa.database-platform=org.hibernate.dialect.H2Dialect \
              --spring.sql.init.mode=never >/home/ec2-user/app.log 2>&1 &
            # Wait for backend to listen on 8080 (max ~60s), then quick health
            for i in $(seq 1 30); do
              if ss -lntp | grep -q ":8080"; then
                echo "Backend is listening on 8080"; break; fi
              sleep 2
            done
            if ! ss -lntp | grep -q ":8080"; then
              echo "ERROR: Backend did not start. Recent logs:"; tail -n 200 /home/ec2-user/app.log || true; exit 1;
            fi
            curl -sS -m 5 http://127.0.0.1:8080/api/items | head -c 400 || true
            # avoid non-critical stderr causing failure
            set +e
            sudo systemctl is-active nginx || true
            echo "DONE"
            exit 0

      - name: External reachability check (HTTP)
        env:
          BASTION: ${{ secrets.BASTION_HOST }}
        run: |
          set -e
          echo "Probing http://$BASTION ..."
          if ! curl -sS -m 8 -I "http://$BASTION/" | head -n 1; then
            echo "ERROR: Port 80 unreachable from GitHub runner."; exit 1;
          fi
          echo "Probing http://$BASTION/api/items ..."
          curl -sS -m 8 "http://$BASTION/api/items" | head -c 400 || true

      - name: Notify Success
        if: ${{ success() }}
        run: echo "Deployment finished"
